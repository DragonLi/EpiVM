\section{The Epic Language}

Epic is based on the untyped $\lambda$-calculus with some extensions.
It supports primitives such as strings and integers, as well as tagged
unions. There are additional control structures for specifying
evaluation order, primitive loop constructs, and calling foreign
functions. Foreign function calls are annotated with types, to assist
with marshaling values between Epic and C, but otherwise there are no
type annotations and there is no type checking --- as Epic is intended
as an intermediate language, it is assumed that the high level
language has already performed any necessary type checking. The
abstract syntax of the core language is given in Figure \ref{epicsyn}.
As a shorthand, we use de Bruijn telescope notation, $\tx$, to denote
a sequence of $\vx$.

\newcommand{\Con}[2]{\DC{Con}\:#1(#2)}

\FFIG{
\AR{
\begin{array}{rcll}\\
\vp & ::= & \vec{\VV{def}} & \mbox{(Epic program)} \\
\VV{def} & ::= & \vx(\tx) = \vt &
\mbox{(Top level definition)} \\
\\
\vt & ::= & \vx & \mbox{(Variable)} \\
& \mid &  \vt(\ttt) & \mbox{(Function application)} \\
& \mid & \lambda\vx\SC\vt & \mbox{(Lambda binding)} \\
& \mid & \RW{let}\:\vx\:=\:\vt\:\RW{in}\:\vt & \mbox{(Let
  binding)} \\
& \mid & \Con{\vi}{\ttt} & \mbox{(Constructor application)} \\
& \mid & \vt ! \vi & \mbox{(Argument projection)} \\
& \mid & \vt\:\VV{op}\:\vt & \mbox{(Infix operator)} \\
& \mid & \RW{if}\:\vt\:\RW{then}\:\vt\:\RW{else}\:\vt & \mbox{(Conditional)}\\
& \mid & \RW{case}\:\vt\:\RW{of}\:\vec{\VV{alt}} & \mbox{(Case expressions)}\\
& \mid & \RW{lazy}(\vt) & \mbox{(Lazy evaluation)} \\
& \mid & \RW{effect}(\vt) & \mbox{(Evaluate an effectful term)} \\
& \mid & \RW{while}(\vt,\vt) & \mbox{(While loops)} \\
& \mid & \vx := \:\vt\:\RW{in}\:\vt & \mbox{(Variable update)} \\
& \mid & \RW{foreign}\:\vT\:\VV{str}\:\vec{(\vt\Hab\vT)} & \mbox{(Foreign call)} \\
& \mid & \RW{malloc}\:\ve\:\ve & \mbox{(Manual allocation)} \\
& \mid & \vi \mid \vf \mid \vc \mid \vb \mid \VV{str} & \mbox{(Constants)} \\
\\
\VV{alt} & ::= &
\Con{\vi}{\tx} \cq \vt & \mbox{(Constructors)}\\
& \mid & \vi \cq \vt & \mbox{(Integer constants)} \\
& \mid & \RW{default} \cq \vt & \mbox{(Match anything)} \\
\end{array}
\medskip
\\
\begin{array}{rcll}
\VV{op} & ::= & + \mid - \mid \times \mid / \mid\:
==\: \mid \:<\: \mid \:\le\: \mid \:>\: \mid \:\ge \\
\end{array}
\medskip
\\
\begin{array}{rcll}
\vx & ::= & \mbox{Variable name} \\
\vi & ::= & \mbox{Integer literal} \\
\vf & ::= & \mbox{Floating point literal} \\
\vc & ::= & \mbox{Character literal} \\
\vb & ::= & \mbox{Boolean literal} \: \DC{True} \mid \DC{False} \\
\VV{str} & ::= & \mbox{String literal} \\
\end{array}
\medskip
\\
\begin{array}{rcll}
\vT & ::= & \TC{Int} \mid \TC{Char} \mid \TC{Bool} \mid \TC{Float}
\mid \TC{String} & \mbox{(Primitives)} \\
 & \mid & \TC{Unit} & \mbox{(Unit type)} \\
 & \mid & \TC{Ptr} & \mbox{(Foreign pointers)} \\
 & \mid & \TC{Fun} & \mbox{(Any function type)} \\
 & \mid & \TC{Data} & \mbox{(Any data type)} \\
 & \mid & \TC{Any} & \mbox{(Polymorphic type)} \\
\end{array}
}
}
{Epic syntax}
{epicsyn}

\subsection{Definitions}

An Epic program consists of a sequence of \remph{untyped} function
definitions, with zero or more arguments, 

Expressions. \texttt{let}, \texttt{case}, \texttt{lazy}

\subsection{Types}

\texttt{Int}, \texttt{Float}, \texttt{Bool}, \texttt{Data}, \texttt{Ptr},
\texttt{Unit}. Unchecked! Used for marshalling foreign functions only.

Run-time representation (31 bit ints).

\subsection{Imperative Features}

Motivation: no need to limit ourselves to functional languages, and in
some situations may help a high level language implement some optimisations.
\texttt{while}, variable update.

\subsection{Foreign Functions}

Calling, exporting.

\subsection{Haskell API}

Function names. Distinction between Haskell application and Epic
application (\texttt{@@}). Underscore convention -- it's for primitive
language constructs, arises because we can't have ``let'', ``if'',
``case'' etc as function names, and extended to other primitives such
as operators, foreign calls (anything that'd be a keyword in general).
