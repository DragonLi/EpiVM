\section{Related Work}

%% GHC's run-time system~\cite{stg, evalpush}, ABC
%% machine~\cite{abc-machine} and why we don't just use one of them
%% (no useful interface, imposes constraints on the type system).
%% Some influence from GRIN~\cite{grin-project}.

Epic is currently used by Agda and Idris~\cite{plpv11}, as well as the
development version of Epigram~\cite{levitation}. Initial
benchmarking~\cite{scrap-engine} shows that the code generated by Epic
can be competitive with Java and is not significantly worse than C.
Epic uses techniques from other functional language back
ends~\cite{evalpush,stg,abc-machine} but deliberately exposes its core
language as an API to make it as reusable as possible. Although there
is always likely to be a trade off between reusability and efficiency,
exposing the API will make it easier for other language researchers to
build a new compiler quickly. 
%
As far as we are aware, Epic occupies a unique point in the design space of
code generation tools --- it is sufficiently high level that it captures common
functional language abstractions without being so high level that it imposes
constraints such as a type system on the language it is compiling. 
Alonzo, for example, is a prototype compiler for Agda~\cite{alonzo} which compiles
via GHC, but requires coercions in the generated code in order for it to be accepted
by GHC's type checker. Coq's program extraction tool~\cite{extraction-coq}
also aims to generate executable code via a high level language, similarly requiring
coercions where Coq terms can not be given a type in the high level language.
In contrast, systems such as the Lazy Virtual Machine~\cite{lvm},
C\texttt{--}~\cite{c--} and LLVM~\cite{llvm} are
designed as lower level target languages rather than high level APIs. We could
nevertheless consider using these tools for Epic code generation.

%C--~\cite{c--} and LLVM~\cite{llvm}
%as possible code generation strategies. Supercompilation for
%optimisations~\cite{mitchell-super}.

\section{Conclusion}

Epic provides a simple path for language researchers to convert
experimental languages (e.g. experimenting with new type systems or
domain specific language design) into larger scale, usable tools, by
providing an API for generating a compiler, dealing with
well-understood but difficult to implement problems such as 
naming and scope management,
code generation, interfacing with foreign functions and
garbage collection. 
In this paper we have seen two examples of languages which can be
compiled via Epic, both functionally based, but with different
features. The high-level recipe for each is the same: define primitive
functions as run-time support, then translate the abstract syntax into
concrete Epic functions, using a combinator style API.  In addition,
we have implemented a compiler for \LamPi{}~\cite{simply-easy}, a
dependently typed language, which shows how Epic can handle languages
with more expressive type
systems\footnote{\url{http://www.idris-lang.org/examples/LambdaPi.hs}}.


\subsubsection{Future work}

%Epic is currently used in practice by a dependently typed functional
%language, Idris~\cite{plpv11}, and experimentally by
%Agda~\cite{norell-thesis} and Epigram~\cite{levitation}. 

Since Epic is currently used in practice by a number of dependently
typed functional languages, future work will have an emphasis on
providing an efficient executable environment for these and related
languages. An interesting research question, for example, is whether
the rich type systems of these languages can be used to guide
optimisation, and if so how to present the information gained by the
type system to the compiler.

Currently, Epic compiles to machine code via C, using the Boehm
conservative garbage collector~\cite{boehm-gc}. While this has been
reasonably efficient in practice, we believe that an LLVM based
implementation~\cite{llvm,llvm-haskell} with accurate garbage
collection would be more appropriate as it could take advantage of
functional language features such as immutability of data. 

Perhaps more importantly, as a very simple functional language Epic is
a convenient platform with which to experiment with functional
compilation techniques. For example, we are developing an evaluator
which will be a starting point for experimenting with
supercompilation~\cite{mitchell-super} and partial evaluation.
Of course, any language which uses Epic as a back end will stand to
gain from future optimisation efforts!
