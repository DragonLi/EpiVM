\section{Related Work}

%% GHC's run-time system~\cite{stg, evalpush}, ABC
%% machine~\cite{abc-machine} and why we don't just use one of them
%% (no useful interface, imposes constraints on the type system).
%% Some influence from GRIN~\cite{grin-project}.

Epic is currently used by Agda and Idris~\cite{plpv11}, as well as the
development version of Epigram~\cite{levitation}. Initial
benchmarking~\cite{scrap-engine} shows that the code generated by Epic
can be competitive with Java and is not significantly worse than C.
Epic uses techniques from other functional language back
ends~\cite{evalpush,stg,abc-machine} but deliberately exposes its core
language as an API to make it as reusable as possible. Although there
is likely to always be a trade off between reusability and efficiency,
exposing the API will make it easier for other language researchers to
build a new compiler quickly. The Lazy Virtual Machine~\cite{lvm} has
similar goals but it designed as a lower level target language, rather
than a high level API. 

%C--~\cite{c--} and LLVM~\cite{llvm}
%as possible code generation strategies. Supercompilation for
%optimisations~\cite{mitchell-super}.

\section{Conclusion}

Epic provides a simple path for language researchers to convert
experimental languages (e.g. experimenting with new type systems or
domain specific language design) into larger scale, usable tools, by
providing an API for generating a compiler, dealing with
well-understood but difficult to implement problems such as lambda
lifting, code generation, interfacing with foreign functions and
garbage collection. 

In this paper we have seen two examples of languages which can be
compiled via Epic, both functionally based, but with different
features. The high-level recipe for each is the same: define primitive
functions as run-time support, then translate the abstract syntax into
concrete Epic functions, using a combinator style API.

\subsubsection{Future work}

Epic is currently used in practice by a dependently typed functional
language, Idris~\cite{idris-plpv}, and experimentally by
Agda~\cite{norell-thesis} and Epigram~\cite{levitation}. Future work
will therefore have an emphasis on providing an efficient executable
environment for these and related languages. An interesting research
question, for example, is whether the rich type systems of these languages
can be used to guide optimisation, and if so how to present the
information gained by the type system to the compiler.

Currently, Epic compiles to machine code via C, using the Boehm
conservative garbage collector~\cite{boehm-gc}. While this has been
reasonably efficient in practice, we believe that an LLVM based
implementation~\cite{llvm,llvm-haskell} with accurate garbage
collection would be more appropriate. Of course, any language which
uses Epic as a back end will stand to gain from future optimisation
efforts!
