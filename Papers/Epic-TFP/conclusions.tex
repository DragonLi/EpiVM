\section{Related Work}

%% GHC's run-time system~\cite{stg, evalpush}, ABC
%% machine~\cite{abc-machine} and why we don't just use one of them
%% (no useful interface, imposes constraints on the type system).
%% Some influence from GRIN~\cite{grin-project}.

Epic is currently used by Agda and Idris~\cite{plpv11}, as well as the
development version of Epigram~\cite{levitation}. Initial
benchmarking~\cite{scrap-engine} shows that the code generated by Epic
can be competitive with Java and is not significantly worse than C.
Epic uses techniques from other functional language back
ends~\cite{evalpush,stg,abc-machine} but deliberately exposes its core
language as an API to make it as reusable as possible. Although there
is likely to always be a trade off between reusability and efficiency,
exposing the API will make it easier for other language researchers to
build a new compiler quickly. The Lazy Virtual Machine~\cite{lvm} has
similar goals but it designed as a lower level target language, rather
than a high level API. 

%C--~\cite{c--} and LLVM~\cite{llvm}
%as possible code generation strategies. Supercompilation for
%optimisations~\cite{mitchell-super}.

\section{Conclusion}

Epic provides a simple path for language researchers to convert
experimental languages (e.g. experimenting with new type systems or
domain specific language design) into larger scale, usable tools, by
providing an API for generating a compiler, dealing with
well-understood but difficult to implement problems such as lambda
lifting, code generation, interfacing with foreign functions and
garbage collection.

